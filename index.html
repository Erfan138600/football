<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ø¨Ø§Ø²ÛŒ ÙÙˆØªØ¨Ø§Ù„ Ù†Ø¦ÙˆÙ†ÛŒ - Ù†Ø³Ø®Ù‡ Ø¨Ù‡Ø¨ÙˆØ¯ ÛŒØ§ÙØªÙ‡</title>
    <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Vazir:wght@400;700&display=swap');
        
        body {
            font-family: 'Vazir', sans-serif;
            background: linear-gradient(45deg, #0a0a0a, #1a0a1a, #0a1a1a);
            background-size: 400% 400%;
            animation: gradientShift 15s ease infinite;
        }
        
        @keyframes gradientShift {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }
        
        .neon-glow {
            box-shadow: 0 0 20px #00ffff, 0 0 40px #00ffff, 0 0 60px #00ffff;
        }
        
        .neon-text {
            color: #00ffff;
            text-shadow: 0 0 10px #00ffff, 0 0 20px #00ffff, 0 0 30px #00ffff;
        }
        
        .game-canvas {
            border: 3px solid #00ffff;
            box-shadow: 0 0 30px #00ffff, inset 0 0 30px rgba(0, 255, 255, 0.1);
            background: radial-gradient(circle at center, #001a1a, #000a0a);
        }
        
        .mobile-controls {
            background: rgba(0, 255, 255, 0.1);
            border: 2px solid #00ffff;
            border-radius: 50%;
            backdrop-filter: blur(10px);
        }
        
        .score-board {
            background: linear-gradient(45deg, rgba(0, 255, 255, 0.1), rgba(255, 0, 255, 0.1));
            border: 2px solid #00ffff;
            backdrop-filter: blur(15px);
        }
        
        .developer-tag {
            background: linear-gradient(45deg, #ff006e, #8338ec, #3a86ff);
            background-size: 200% 200%;
            animation: gradientShift 3s ease infinite;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        
        .control-button {
            background: rgba(0, 255, 255, 0.2);
            border: 2px solid #00ffff;
            color: #00ffff;
            transition: all 0.3s ease;
        }
        
        .control-button:hover, .control-button:active {
            background: rgba(0, 255, 255, 0.4);
            box-shadow: 0 0 20px #00ffff;
            transform: scale(1.05);
        }
    </style>
</head>
<body class="min-h-screen text-white overflow-x-hidden">
    <!-- Header -->
    <div class="text-center py-4">
        <h1 class="text-4xl md:text-6xl font-bold neon-text mb-2">âš½ Ø¨Ø§Ø²ÛŒ ÙÙˆØªØ¨Ø§Ù„ Ù†Ø¦ÙˆÙ†ÛŒ âš½</h1>
        <p class="text-lg text-gray-300">Ù†Ø³Ø®Ù‡ Ø¨Ù‡Ø¨ÙˆØ¯ ÛŒØ§ÙØªÙ‡ Ø¨Ø±Ø§ÛŒ Ù…ÙˆØ¨Ø§ÛŒÙ„</p>
    </div>

    <!-- Game Container -->
    <div class="flex flex-col items-center px-4">
        <!-- Score Board -->
        <div class="score-board rounded-lg p-4 mb-4 text-center">
            <div class="flex justify-between items-center w-full max-w-md">
                <div class="text-center">
                    <p class="text-sm text-gray-300">Ø´Ù…Ø§</p>
                    <p id="playerScore" class="text-3xl font-bold neon-text">0</p>
                </div>
                <div class="text-2xl">VS</div>
                <div class="text-center">
                    <p class="text-sm text-gray-300">Ú©Ø§Ù…Ù¾ÛŒÙˆØªØ±</p>
                    <p id="aiScore" class="text-3xl font-bold text-pink-400">0</p>
                </div>
            </div>
        </div>

        <!-- Game Canvas -->
        <canvas id="gameCanvas" class="game-canvas rounded-lg mb-4" width="800" height="400"></canvas>

        <!-- Mobile Controls -->
        <div class="md:hidden grid grid-cols-3 gap-4 mb-4 w-full max-w-xs">
            <div></div>
            <button id="upBtn" class="mobile-controls control-button h-16 w-16 text-2xl">â†‘</button>
            <div></div>
            <button id="leftBtn" class="mobile-controls control-button h-16 w-16 text-2xl">â†</button>
            <button id="downBtn" class="mobile-controls control-button h-16 w-16 text-2xl">â†“</button>
            <button id="rightBtn" class="mobile-controls control-button h-16 w-16 text-2xl">â†’</button>
        </div>

        <!-- Game Controls -->
        <div class="flex flex-wrap justify-center gap-4 mb-4">
            <button id="startBtn" class="px-6 py-3 bg-green-600 hover:bg-green-700 rounded-lg font-bold transition">Ø´Ø±ÙˆØ¹ Ø¨Ø§Ø²ÛŒ</button>
            <button id="pauseBtn" class="px-6 py-3 bg-yellow-600 hover:bg-yellow-700 rounded-lg font-bold transition">ØªÙˆÙ‚Ù</button>
            <button id="resetBtn" class="px-6 py-3 bg-red-600 hover:bg-red-700 rounded-lg font-bold transition">Ø±ÛŒØ³Øª</button>
        </div>

        <!-- Instructions -->
        <div class="text-center max-w-2xl mb-8">
            <h3 class="text-xl font-bold mb-2 text-cyan-400">Ø±Ø§Ù‡Ù†Ù…Ø§ÛŒ Ø¨Ø§Ø²ÛŒ:</h3>
            <p class="text-gray-300 mb-2">
                <strong>Ú©Ø§Ù…Ù¾ÛŒÙˆØªØ±:</strong> Ú©Ù„ÛŒØ¯Ù‡Ø§ÛŒ WASD ÛŒØ§ Ù¾ÛŒÚ©Ø§Ù†â€ŒÙ‡Ø§ | <strong>Ù…ÙˆØ¨Ø§ÛŒÙ„:</strong> Ø¯Ú©Ù…Ù‡â€ŒÙ‡Ø§ÛŒ Ù„Ù…Ø³ÛŒ
            </p>
            <p class="text-gray-300">Ù‡Ø¯Ù: ØªÙˆÙ¾ Ø±Ø§ Ø¨Ù‡ Ø¯Ø±ÙˆØ§Ø²Ù‡ Ø­Ø±ÛŒÙ Ø¨Ø±Ø³Ø§Ù†ÛŒØ¯! Ø§ÙˆÙ„ÛŒÙ† Ù†ÙØ±ÛŒ Ú©Ù‡ 5 Ú¯Ù„ Ø¨Ø²Ù†Ø¯ Ø¨Ø±Ù†Ø¯Ù‡ Ø§Ø³Øª!</p>
        </div>
    </div>

    <!-- Developer Credit -->
    <div class="text-center py-8">
        <p class="text-lg">
            <span class="text-gray-400">Ø¨Ø±Ù†Ø§Ù…Ù‡â€ŒÙ†ÙˆÛŒØ³:</span> 
            <span class="developer-tag font-bold text-xl">Ø¹Ø±ÙØ§Ù† Ø¹Ù„ÛŒØ®Ø§Ù†ÛŒ</span>
        </p>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        // Responsive canvas
        function resizeCanvas() {
            const container = canvas.parentElement;
            const maxWidth = Math.min(container.clientWidth - 32, 800);
            const aspectRatio = 800 / 400;
            
            canvas.style.width = maxWidth + 'px';
            canvas.style.height = (maxWidth / aspectRatio) + 'px';
        }
        
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();

        // Game variables
        let gameRunning = false;
        let playerScore = 0;
        let aiScore = 0;
        const WINNING_SCORE = 5;

        // Game objects
        const player = {
            x: 100,
            y: 200,
            radius: 25,
            speed: 5,
            color: '#00ffff'
        };

        const ai = {
            x: 700,
            y: 200,
            radius: 25,
            speed: 3.5,
            color: '#ff00ff'
        };

        const ball = {
            x: 400,
            y: 200,
            radius: 15,
            dx: 4,
            dy: 2,
            color: '#ffffff',
            trail: []
        };

        // Goals
        const leftGoal = { x: 0, y: 120, width: 30, height: 160 };
        const rightGoal = { x: 770, y: 120, width: 30, height: 160 };

        // Input handling
        const keys = {};
        
        document.addEventListener('keydown', (e) => {
            keys[e.key.toLowerCase()] = true;
        });
        
        document.addEventListener('keyup', (e) => {
            keys[e.key.toLowerCase()] = false;
        });

        // Mobile controls
        const mobileControls = {
            up: false,
            down: false,
            left: false,
            right: false
        };

        function setupMobileControls() {
            const buttons = {
                upBtn: 'up',
                downBtn: 'down',
                leftBtn: 'left',
                rightBtn: 'right'
            };

            Object.keys(buttons).forEach(btnId => {
                const btn = document.getElementById(btnId);
                const direction = buttons[btnId];
                
                btn.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    mobileControls[direction] = true;
                });
                
                btn.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    mobileControls[direction] = false;
                });
                
                btn.addEventListener('mousedown', (e) => {
                    e.preventDefault();
                    mobileControls[direction] = true;
                });
                
                btn.addEventListener('mouseup', (e) => {
                    e.preventDefault();
                    mobileControls[direction] = false;
                });
            });
        }

        setupMobileControls();

        // Drawing functions
        function drawCircle(obj) {
            ctx.beginPath();
            ctx.arc(obj.x, obj.y, obj.radius, 0, Math.PI * 2);
            ctx.fillStyle = obj.color;
            ctx.fill();
            ctx.strokeStyle = obj.color;
            ctx.lineWidth = 3;
            ctx.stroke();
            
            // Neon glow effect
            ctx.shadowColor = obj.color;
            ctx.shadowBlur = 20;
            ctx.fill();
            ctx.shadowBlur = 0;
        }

        function drawField() {
            // Field background
            ctx.fillStyle = 'rgba(0, 50, 0, 0.3)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Center line
            ctx.strokeStyle = '#00ffff';
            ctx.lineWidth = 3;
            ctx.setLineDash([10, 10]);
            ctx.beginPath();
            ctx.moveTo(400, 0);
            ctx.lineTo(400, 400);
            ctx.stroke();
            
            // Center circle
            ctx.beginPath();
            ctx.arc(400, 200, 80, 0, Math.PI * 2);
            ctx.stroke();
            ctx.setLineDash([]);
            
            // Goals
            ctx.fillStyle = '#ff006e';
            ctx.fillRect(leftGoal.x, leftGoal.y, leftGoal.width, leftGoal.height);
            ctx.fillRect(rightGoal.x, rightGoal.y, rightGoal.width, rightGoal.height);
            
            // Goal glow
            ctx.shadowColor = '#ff006e';
            ctx.shadowBlur = 15;
            ctx.fillRect(leftGoal.x, leftGoal.y, leftGoal.width, leftGoal.height);
            ctx.fillRect(rightGoal.x, rightGoal.y, rightGoal.width, rightGoal.height);
            ctx.shadowBlur = 0;
        }

        function drawBallTrail() {
            for (let i = 0; i < ball.trail.length; i++) {
                const alpha = (i + 1) / ball.trail.length * 0.5;
                const pos = ball.trail[i];
                ctx.beginPath();
                ctx.arc(pos.x, pos.y, ball.radius * alpha, 0, Math.PI * 2);
                ctx.fillStyle = `rgba(255, 255, 255, ${alpha})`;
                ctx.fill();
            }
        }

        // Game logic
        function updatePlayer() {
            if (keys['w'] || keys['arrowup'] || mobileControls.up) {
                player.y = Math.max(player.radius, player.y - player.speed);
            }
            if (keys['s'] || keys['arrowdown'] || mobileControls.down) {
                player.y = Math.min(canvas.height - player.radius, player.y + player.speed);
            }
            if (keys['a'] || keys['arrowleft'] || mobileControls.left) {
                player.x = Math.max(player.radius, player.x - player.speed);
            }
            if (keys['d'] || keys['arrowright'] || mobileControls.right) {
                player.x = Math.min(canvas.width - player.radius, player.x + player.speed);
            }
        }

        function updateAI() {
            // Smart AI that predicts ball movement
            const predictedBallX = ball.x + ball.dx * 30;
            const predictedBallY = ball.y + ball.dy * 30;
            
            // Move towards predicted ball position
            const dx = predictedBallX - ai.x;
            const dy = predictedBallY - ai.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            if (distance > 5) {
                ai.x += (dx / distance) * ai.speed;
                ai.y += (dy / distance) * ai.speed;
            }
            
            // Keep AI within bounds
            ai.x = Math.max(ai.radius, Math.min(canvas.width - ai.radius, ai.x));
            ai.y = Math.max(ai.radius, Math.min(canvas.height - ai.radius, ai.y));
        }

        function updateBall() {
            // Update trail
            ball.trail.push({ x: ball.x, y: ball.y });
            if (ball.trail.length > 10) {
                ball.trail.shift();
            }
            
            ball.x += ball.dx;
            ball.y += ball.dy;
            
            // Bounce off top and bottom walls
            if (ball.y <= ball.radius || ball.y >= canvas.height - ball.radius) {
                ball.dy = -ball.dy;
                createParticles(ball.x, ball.y);
            }
            
            // Check collision with players
            checkPlayerCollision(player);
            checkPlayerCollision(ai);
            
            // Check goals
            if (ball.x <= leftGoal.x + leftGoal.width && 
                ball.y >= leftGoal.y && 
                ball.y <= leftGoal.y + leftGoal.height) {
                aiScore++;
                updateScore();
                resetBall();
                showGoalEffect();
            }
            
            if (ball.x >= rightGoal.x && 
                ball.y >= rightGoal.y && 
                ball.y <= rightGoal.y + rightGoal.height) {
                playerScore++;
                updateScore();
                resetBall();
                showGoalEffect();
            }
            
            // Keep ball in bounds (sides)
            if (ball.x <= ball.radius) {
                ball.x = ball.radius;
                ball.dx = -ball.dx;
            }
            if (ball.x >= canvas.width - ball.radius) {
                ball.x = canvas.width - ball.radius;
                ball.dx = -ball.dx;
            }
        }

        function checkPlayerCollision(playerObj) {
            const dx = ball.x - playerObj.x;
            const dy = ball.y - playerObj.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            if (distance < ball.radius + playerObj.radius) {
                // Calculate collision angle
                const angle = Math.atan2(dy, dx);
                const speed = Math.sqrt(ball.dx * ball.dx + ball.dy * ball.dy);
                
                // Reflect ball
                ball.dx = Math.cos(angle) * speed * 1.1;
                ball.dy = Math.sin(angle) * speed * 1.1;
                
                // Add some randomness
                ball.dx += (Math.random() - 0.5) * 2;
                ball.dy += (Math.random() - 0.5) * 2;
                
                // Limit speed
                const maxSpeed = 8;
                const currentSpeed = Math.sqrt(ball.dx * ball.dx + ball.dy * ball.dy);
                if (currentSpeed > maxSpeed) {
                    ball.dx = (ball.dx / currentSpeed) * maxSpeed;
                    ball.dy = (ball.dy / currentSpeed) * maxSpeed;
                }
                
                createParticles(ball.x, ball.y);
            }
        }

        function resetBall() {
            ball.x = canvas.width / 2;
            ball.y = canvas.height / 2;
            ball.dx = (Math.random() > 0.5 ? 1 : -1) * (3 + Math.random() * 2);
            ball.dy = (Math.random() - 0.5) * 4;
            ball.trail = [];
        }

        let particles = [];
        
        function createParticles(x, y) {
            for (let i = 0; i < 10; i++) {
                particles.push({
                    x: x,
                    y: y,
                    dx: (Math.random() - 0.5) * 8,
                    dy: (Math.random() - 0.5) * 8,
                    life: 1,
                    decay: 0.02
                });
            }
        }

        function updateParticles() {
            particles = particles.filter(p => {
                p.x += p.dx;
                p.y += p.dy;
                p.life -= p.decay;
                
                if (p.life > 0) {
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, 3, 0, Math.PI * 2);
                    ctx.fillStyle = `rgba(0, 255, 255, ${p.life})`;
                    ctx.fill();
                    return true;
                }
                return false;
            });
        }

        function showGoalEffect() {
            // Flash effect
            canvas.style.filter = 'brightness(2)';
            setTimeout(() => {
                canvas.style.filter = 'brightness(1)';
            }, 200);
            
            // Create goal particles
            for (let i = 0; i < 50; i++) {
                particles.push({
                    x: canvas.width / 2,
                    y: canvas.height / 2,
                    dx: (Math.random() - 0.5) * 15,
                    dy: (Math.random() - 0.5) * 15,
                    life: 1,
                    decay: 0.01
                });
            }
        }

        function updateScore() {
            document.getElementById('playerScore').textContent = playerScore;
            document.getElementById('aiScore').textContent = aiScore;
            
            if (playerScore >= WINNING_SCORE || aiScore >= WINNING_SCORE) {
                gameRunning = false;
                setTimeout(() => {
                    alert(playerScore >= WINNING_SCORE ? 'Ø´Ù…Ø§ Ø¨Ø±Ù†Ø¯Ù‡ Ø´Ø¯ÛŒØ¯! ğŸ‰' : 'Ú©Ø§Ù…Ù¾ÛŒÙˆØªØ± Ø¨Ø±Ù†Ø¯Ù‡ Ø´Ø¯! ğŸ˜…');
                }, 100);
            }
        }

        function gameLoop() {
            if (!gameRunning) return;
            
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            drawField();
            drawBallTrail();
            updatePlayer();
            updateAI();
            updateBall();
            updateParticles();
            
            drawCircle(player);
            drawCircle(ai);
            drawCircle(ball);
            
            requestAnimationFrame(gameLoop);
        }

        // Game controls
        document.getElementById('startBtn').addEventListener('click', () => {
            gameRunning = true;
            gameLoop();
        });

        document.getElementById('pauseBtn').addEventListener('click', () => {
            gameRunning = false;
        });

        document.getElementById('resetBtn').addEventListener('click', () => {
            gameRunning = false;
            playerScore = 0;
            aiScore = 0;
            updateScore();
            resetBall();
            player.x = 100;
            player.y = 200;
            ai.x = 700;
            ai.y = 200;
            particles = [];
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawField();
            drawCircle(player);
            drawCircle(ai);
            drawCircle(ball);
        });

        // Initialize game
        drawField();
        drawCircle(player);
        drawCircle(ai);
        drawCircle(ball);
        updateScore();
    </script>
</body>
</html>
